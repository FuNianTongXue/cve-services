import copy
import datetime as dt
import json
import requests
import time
import uuid

from requests.models import Response
from src import env, utils
from src.utils import ok_response_contains, response_contains_json

CVE_URL = '/api/cve'
cve_id = 'CVE-1999-0001'
cve_id_dne = 'CVE-3000-0001'
curr_cve_id = 'CVE-2021-0005'
update_cve_id = create_cve_id = 'CVE-2000-0008'
reserved_cve_id = 'CVE-2017-5833'
reject_cve_id = 'CVE-2009-0009'


### GET /cve ####
def test_get_all_cves():
    """ services api accepts requests for all CVEs for secretariat users """
    res = requests.get(
        f'{env.AWG_BASE_URL}{CVE_URL}/',
        headers=utils.BASE_HEADERS
    )
    assert res.status_code == utils.HTTP_OK
    assert len(json.loads(res.content.decode())['cveRecords']) >= 1


def test_get_cve_by_time_modified():
    t_before = dt.datetime.now().strftime('%Y-%m-%dT%H:%M:%S')
    time.sleep(1)
    update_cve('CVE-2021-0004_public', 'CVE-2021-0004')
    time.sleep(1)
    update_cve('CVE-2021-0005_public', 'CVE-2021-0005')
    time.sleep(1)
    t_after = dt.datetime.now().strftime('%Y-%m-%dT%H:%M:%S')

    res = requests.get(
        f'{env.AWG_BASE_URL}{CVE_URL}/',
        headers=utils.BASE_HEADERS,
        params={
            'time_modified.lt': t_after,
            'time_modified.gt': t_before
        }
    )
    assert res.status_code == utils.HTTP_OK
    assert len(json.loads(res.content.decode())['cveRecords']) >= 2


def test_get_cve_by_count_only_true():
    """ count_only set to True using number 1 """
    res = requests.get(
        f'{env.AWG_BASE_URL}{CVE_URL}/',
        headers=utils.BASE_HEADERS,
        params={
            'count_only' : 1
        }

    )
    assert len(json.loads(res.content.decode())) == 1 # only count is returned
    assert json.loads(res.content.decode())['totalCount'] == 114
    assert res.status_code == 200


def test_get_cve_by_count_only_false():
    """ count_only set to False using number 0, returns all records"""
    res = requests.get(
        f'{env.AWG_BASE_URL}{CVE_URL}/',
        headers=utils.BASE_HEADERS,
        params={
            'count_only' : 0
        }

    )
    print(json.loads(res.content.decode()))
    assert len(json.loads(res.content.decode())['cveRecords']) == 114  # all records are returned
    assert res.status_code == 200


def test_get_cve_invalid_count_number():
    """ count_only can only be set to 0 or 1 """
    res = requests.get(
        f'{env.AWG_BASE_URL}{CVE_URL}/',
        headers=utils.BASE_HEADERS,
        params={
            'count_only' : 11
        }
    )
    assert res.status_code == 400
    response_contains_json(res, 'error', 'BAD_INPUT')


def test_get_cve_invalid_count_value():
    """ count_only can only be set to 0 or 1 """
    res = requests.get(
        f'{env.AWG_BASE_URL}{CVE_URL}/',
        headers=utils.BASE_HEADERS,
        params={
            'count_only' : True
        }
    )
    assert res.status_code == 400
    response_contains_json(res, 'error', 'BAD_INPUT')


def test_get_cve_id_filter_by_public_state():
    """ CVE ID filter endpoint with state 'PUBLIC' """
    res = requests.get(
        f'{env.AWG_BASE_URL}{CVE_URL}/',
        headers=utils.BASE_HEADERS,
        params={
            'state': 'PUBLIC'
        }
    )
    assert res.status_code == 200
    recordsLength = len(json.loads(res.content.decode())['cveRecords'])
    assert recordsLength >= 62
    for i in range(recordsLength):
        assert json.loads(res.content.decode())['cveRecords'][i]['CVE_data_meta']['STATE'] == 'PUBLIC'


def test_get_cve_id_filter_by_reject_state():
    """ CVE ID filter endpoint with state 'REJECT' """
    res = requests.get(
        f'{env.AWG_BASE_URL}{CVE_URL}/',
        headers=utils.BASE_HEADERS,
        params={
            'state': 'REJECT'
        }
    )
    assert res.status_code == 200
    recordsLength = len(json.loads(res.content.decode())['cveRecords'])
    assert recordsLength >= 52
    for i in range(recordsLength):
        assert json.loads(res.content.decode())['cveRecords'][i]['CVE_data_meta']['STATE'] == 'REJECT'


def test_get_cve_id_filter_by_unrecognized_state_reserved():
    """ CVE ID filter endpoint does not recognize RESERVED state """
    res = requests.get(
        f'{env.AWG_BASE_URL}{CVE_URL}/',
        headers=utils.BASE_HEADERS,
        params={
            'state': 'RESERVED'
        }
    )
    assert res.status_code == 400
    assert 'RESERVED' not in res.content.decode()


def test_get_cve_id_filter_by_unrecognized_state_available():
    """ CVE ID filter endpoint does not recognize AVAILABLE state """
    res = requests.get(
        f'{env.AWG_BASE_URL}{CVE_URL}/',
        headers=utils.BASE_HEADERS,
        params={
            'state': 'AVAILABLE'
        }
    )
    assert res.status_code == 400
    assert 'AVAILABLE' not in res.content.decode()
    

#### GET /cve/:id ####
def test_get_cve():
    res = requests.get(
        f'{env.AWG_BASE_URL}{CVE_URL}/{cve_id}',
        headers=utils.BASE_HEADERS
    )
    ok_response_contains(res, cve_id)


def test_get_cve_dne():
    res = requests.get(
        f'{env.AWG_BASE_URL}{CVE_URL}/{cve_id_dne}',
        headers=utils.BASE_HEADERS
    )
    assert res.status_code == 404
    response_contains_json(res, 'error', 'CVE_RECORD_DNE')


#### POST /cve/:id ####
def test_create_cve():
    """ publish a cve in the PUBLIC state """
    with open('./src/test/cve_tests/cve_record_fixtures/CVE-2000-0008_public.json') as json_file:
        data = json.load(json_file)
        res = requests.post(
            f'{env.AWG_BASE_URL}{CVE_URL}/{create_cve_id}',
            headers=utils.BASE_HEADERS,
            json=data
        )
        try: 
            ok_response_contains(res, create_cve_id) 
        except AssertionError: 
            assert res.status_code == 400
            response_contains_json(res, 'error', 'CVE_RECORD_EXISTS')


def test_create_cve_mismatch():
    """ the cve id in the json body does not match the cve id in the path parameter """
    with open('./src/test/cve_tests/cve_record_fixtures/CVE-2000-0008_public.json') as json_file:
        data = json.load(json_file)
        res = requests.post(
            f'{env.AWG_BASE_URL}{CVE_URL}/{curr_cve_id}',
            headers=utils.BASE_HEADERS,
            json=data
        )
        assert res.status_code == 400
        response_contains_json(res, 'error', 'CVEID_MISMATCH')


def test_create_cve_reserved_state():
    """ the cve record cannot be created in the RESERVED state """
    with open('./src/test/cve_tests/cve_record_fixtures/CVE-2017-5833_reserved.json') as json_file:
        data = json.load(json_file)
        res = requests.post(
            f'{env.AWG_BASE_URL}{CVE_URL}/{reserved_cve_id}',
            headers=utils.BASE_HEADERS,
            json=data
        )
        assert res.status_code == 400
        response_contains_json(res, 'error', 'CVE_UNSUPPORTED_RECORD_STATE')


def test_create_nonexistent_cveid():
    """ the cve record cannot be created because the CVE ID doesn't exist """
    with open('./src/test/cve_tests/cve_record_fixtures/CVE-3000-0001_nonexistent.json') as json_file:
        data = json.load(json_file)
        res = requests.post(
            f'{env.AWG_BASE_URL}{CVE_URL}/{cve_id_dne}',
            headers=utils.BASE_HEADERS,
            json=data
        )
        assert res.status_code == 403
        response_contains_json(res, 'error', 'CVEID_DNE')


def test_create_existent_cve():
    """ the cve record cannot be created because it already exists """
    with open('./src/test/cve_tests/cve_record_fixtures/CVE-2021-0004_public.json') as json_file:
        data = json.load(json_file)
        res = requests.post(
            f'{env.AWG_BASE_URL}{CVE_URL}/CVE-2021-0004',
            headers=utils.BASE_HEADERS,
            json=data
        )
        assert res.status_code == 400
        response_contains_json(res, 'error', 'CVE_RECORD_EXISTS')


#### PUT /cve/:id ####
def test_update_cve_record():
    with open('./src/test/cve_tests/cve_record_fixtures/CVE-2021-0005_public.json') as json_file:
        data = json.load(json_file)
        res = requests.put(
            f'{env.AWG_BASE_URL}{CVE_URL}/{curr_cve_id}',
            headers=utils.BASE_HEADERS,
            json=data
        )
        ok_response_contains(res, curr_cve_id)


def test_update_cve_mismatch():
    """ the cve id in the json body does not match the cve id in the path parameter """
    with open('./src/test/cve_tests/cve_record_fixtures/CVE-2000-0008_public.json') as json_file:
        data = json.load(json_file)
        res = requests.put(
            f'{env.AWG_BASE_URL}{CVE_URL}/{curr_cve_id}',
            headers=utils.BASE_HEADERS,
            json=data
        )
        assert res.status_code == 400
        response_contains_json(res, 'error', 'CVEID_MISMATCH')


def test_update_cve_reserved_state():
    """ the cve record cannot be changed to the RESERVED state """
    with open('./src/test/cve_tests/cve_record_fixtures/CVE-2017-5833_reserved.json') as json_file:
        data = json.load(json_file)
        res = requests.put(
            f'{env.AWG_BASE_URL}{CVE_URL}/{reserved_cve_id}',
            headers=utils.BASE_HEADERS,
            json=data
        )
        assert res.status_code == 400
        response_contains_json(res, 'error', 'CVE_UNSUPPORTED_RECORD_STATE')


def test_update_nonexistent_cve_id():
    """ the cve record cannot be updated because the CVE ID doesn't exist """
    with open('./src/test/cve_tests/cve_record_fixtures/CVE-3000-0001_nonexistent.json') as json_file:
        data = json.load(json_file)
        res = requests.put(
            f'{env.AWG_BASE_URL}{CVE_URL}/{cve_id_dne}',
            headers=utils.BASE_HEADERS,
            json=data
        )
        assert res.status_code == 403
        response_contains_json(res, 'error', 'CVEID_DNE')


def test_update_nonexistent_cve():
    """ the cve record cannot be updated because it doesn't exist """
    with open('./src/test/cve_tests/cve_record_fixtures/CVE-2009-0009_reject.json') as json_file:
        data = json.load(json_file)
        res = requests.put(
            f'{env.AWG_BASE_URL}{CVE_URL}/{reject_cve_id}',
            headers=utils.BASE_HEADERS,
            json=data
        )
        assert res.status_code == 403
        response_contains_json(res, 'error', 'CVE_RECORD_DNE')


def test_record_submission_too_large():
    """ the cve record cannot be submitted because it is 16 mb"""
    with open('./src/test/cve_tests/cve_record_fixtures/CVE-2021-0004_largeInput.json') as json_file:
        data = json.load(json_file)
        res = requests.post(
            f'{env.AWG_BASE_URL}{CVE_URL}/CVE-2021-0004',
            headers=utils.BASE_HEADERS,
            json=data
        )
        assert res.status_code == 400 # payload is too large
        response_contains_json(res, 'error', 'RECORD_TOO_LARGE')


def test_record_update_too_large():
    """ the cve record cannot be updated because it is 16 mb"""
    with open('./src/test/cve_tests/cve_record_fixtures/CVE-2021-0004_largeInput.json') as json_file:
        data = json.load(json_file)
        res = requests.put(
            f'{env.AWG_BASE_URL}{CVE_URL}/CVE-2021-0004',
            headers=utils.BASE_HEADERS,
            json=data
        )
        assert res.status_code == 400 # payload is too large
        response_contains_json(res, 'error', 'RECORD_TOO_LARGE')
# CVE ENDPOINT UTILITIES
# ==============================================================================
# these are unique to the `{CVE_URL}` endpoint for the AWG system


def update_cve(filename, cveid):
    with open(f'./src/test/cve_tests/cve_record_fixtures/{filename}.json') as json_file:
        data = json.load(json_file)
        res = requests.put(
            f'{env.AWG_BASE_URL}{CVE_URL}/{cveid}',
            headers=utils.BASE_HEADERS,
            json=data
        )
